---
title: "for_va_code"
author: "Zhenyu"
date: "2/24/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r benchmarking}
require(hzz)

# require(pryr)
# require(devtools)
# load_all()

n <-  10 # number of samples for the probit model
num_samples_TN <-  300 # number of TN samples (independent)
num_samples_hzz  <-  400 # number of hzz samples
# read in data (2011 rows, 10 continuous covariates and 1 binary outcome)
df_water <-
  read.csv(file = "../data/water_processed.csv", header = T)

set.seed(666)
df_water  <-  df_water[sample(1:nrow(df_water), n), ]

X  <-  as.matrix(df_water[,-ncol(df_water)])
X  <-  scale(X)
y_raw  <-  df_water$Potability
y  <-  y_raw
y[y == 0]  <-  -1

p  <-  ncol(X)
n  <-  nrow(X)
dim  <-  p + n

pc  <-  hzz::getPrecCov(X, n, p, sigma2 = 2)

TN_lb  <-  y
TN_ub  <-  y
TN_lb[TN_lb == -1]  <-  -Inf
TN_lb[TN_lb == 1]  <-  0
TN_ub[TN_ub == -1]  <-  -0
TN_ub[TN_ub == 1]  <-  Inf
```

```{r timing}
require(hzz)
require(TruncatedNormal)
require(invgamma)
require(rbenchmark)

samples_hzz  <-  array(0, c(num_samples_hzz, dim))
samples_TN <- array(0, c(num_samples_TN, dim))

meanV <- rep(0, dim)

mask <- rep(1, dim)
observed <- rep(1, dim)
parameterSign <- c(rep(0, p), y)

sample_hzz <-
  hzz::getInitialValue(mean = rep(0, dim), constraits = parameterSign)
sample_TN <- sample_hzz

timeRes <- benchmark(
  "TN" = {
    set.seed(666)
    for (i in 1:num_samples_TN) {
      sigma2 <-
        rinvgamma(
          n = 1,
          shape = 2 + dim / 2,
          scale = 2 + sample_TN %*% sample_TN / 2
        )
      pc <- getPrecCov(X, n, p, sigma2 = sigma2)
      
      sample_TN <- TruncatedNormal::rtmvnorm(
        n = 1,
        mu = meanV,
        sigma = pc$covMat,
        lb = c(rep(-Inf, p), TN_lb),
        ub = c(rep(Inf, p), TN_ub)
      )
      samples_TN[i,] <- sample_TN
    }
  },
  "hzz" = {
    engine = createEngine(
      dimension = dim,
      mask = mask,
      observed = observed,
      parameterSign = parameterSign,
      flags = 128,
      info = 1,
      seed = 666
    )
    
    set.seed(666)
    for (i in 1:num_samples_hzz) {
      sigma2 <-
        rinvgamma(
          n = 1,
          shape = 2 + dim / 2,
          scale = 2 + sample_hzz %*% sample_hzz / 2
        )
      pc <- getPrecCov(X, n, p, sigma2 = sigma2)
      
      setMean(sexp = engine$engine, mean = rep(0, dim))
      setPrecision(sexp = engine$engine, precision = pc$precMat)
      
      momentum <- drawMomentum(dim)
      sample_hzz <- getSample(
        position = sample_hzz,
        momentum = momentum,
        t = 10,
        nutsFlg = F,
        engine = engine
      )
      
      samples_hzz[i, ] <- sample_hzz
    }
  },
  replications = 1,
  columns = c(
    "test",
    "replications",
    "elapsed",
    "relative",
    "user.self",
    "sys.self"
  )
)

print(timeRes)
```


```{r check ESS}
require(coda)
require(magrittr)
mcmc(samples_hzz, thin = 1) %>% effectiveSize() %>% summary()
mcmc(samples_TN, thin = 1) %>% effectiveSize() %>% summary()
colMeans(samples_hzz[,1:9])
colMeans(samples_TN[,1:9])

summary(colMeans(samples_hzz[,1:9]))
summary(colMeans(samples_hzz) - colMeans(samples_TN))
```
```{r}
hist(samples_hzz[,29], breaks = 100)
hist(samples_TN[,29], breaks = 100)
```



```{r from LKJ prior}
rm(list = ls())
require(trialr)
require(rbenchmark)
require(hzz)
require(TruncatedNormal)
require(coda)
require(magrittr)

dimension <- 50 # TN limit is about 300 (endless low acceptance rate)
nTN <- 500
nHZZ <- 1000

set.seed(666)
covMat <- rlkjcorr(n = 1, K = dimension, eta = 1)
precMat <- solve(covMat)
meanVec <- rep(0, dimension)

positiveIndex <- seq(from = 1, to = dimension, by = 2)

constraitsHZZ <- rep(-1, dimension)
constraitsHZZ[positiveIndex] <- 1

lbTN <- rep(-Inf, dimension)
ubTN <- rep(0, dimension)
lbTN[positiveIndex] <- 0
ubTN[positiveIndex] <- Inf

timeRes <- benchmark(
  "lkjTN" = {
    set.seed(666)
    samplesTN <- TruncatedNormal::rtmvnorm(
      n = nTN,
      mu = meanVec,
      sigma = covMat,
      lb = lbTN,
      ub = ubTN
    )
  },
  "lkjHZZ" = {
    samplesHZZ <- rcmg(
      n = nHZZ,
      mean = meanVec,
      prec = precMat,
      constraits = constraitsHZZ,
      t = 10,
      burnin = 0,
      cppFlg = T
    )
  },
  replications = 5,
  columns = c(
    "test",
    "replications",
    "elapsed",
    "relative",
    "user.self",
    "sys.self"
  )
)

minESSHZZ <- mcmc(samplesHZZ[,], thin = 1) %>% effectiveSize() %>% min()

cat("HZZ min ESS is", minESSHZZ, "\n", "TN min ESS is", nTN)

timeRes[timeRes$test == "lkjTN", "relative"] <- nTN / timeRes[timeRes$test == "lkjTN", "relative"]
timeRes[timeRes$test == "lkjHZZ", "relative"] <- minESSHZZ / timeRes[timeRes$test == "lkjHZZ", "relative"]

print(timeRes)
```


```{r tmp check invgamma distribution}
hist(rinvgamma(n = 1000, shape = 1, rate = 1), xlim = c(0,20), breaks=1000)
#use https://www.r-bloggers.com/2017/05/5-ways-to-measure-running-time-of-r-code/
```


```{r UPG}
df_water = read.csv(file = "../data/water_potability.csv", header = T)
colnames(df_water)
df_water = df_water[complete.cases(df_water), ]
myprobit <- glm(Potability ~ Sulfate + Solids + Organic_carbon, family = binomial(link = "probit"), data = df_water)
summary(myprobit)

require(UPG)
data("lfp", package = "UPG")
head(lfp, 5)
y <- c(rep(1, 100), rep(0, 1911))
X <- matrix(rnorm(nrow(df_water) * 200, 0 ,1), nrow = nrow(df_water), ncol = 200)
results.logit <- UPG(y = y, X = X, type = "probit", BOOST = F)
UPG.Diag(results.logit)
summary(results.logit)
```